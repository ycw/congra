const ConGra=function(){function t({width:t,height:o,gl:s}){let n=s?s.canvas:document.createElement("canvas");return n.width=t,n.height=o,n.getContext("webgl",{premultipliedAlpha:!1})}return function({width:o,height:s,maxStops:n,twgl:e}){let r=t({width:o,height:s});const a=function({maxStops:t=32}){const o=[];for(const s of Array(t).keys())0!=s&&o.push(`\n    else if (stopOffsets[${s}] >= ang) {\n      float ratio = (ang - stopOffsets[${s-1}])/(stopOffsets[${s}] - stopOffsets[${s-1}]);\n      gl_FragColor = mix(stopColors[${s-1}], stopColors[${s}], ratio);\n    }`);return`precision lowp float;\n    const float PI = ${Math.PI};\n    uniform vec2 resolution;\n    uniform vec2 position;\n    uniform vec4 stopColors[${t}];\n    uniform float stopOffsets[${t}];\n    uniform bool isRepeat;\n    uniform float lastStopOffset;\n    uniform float angle; // offset of start angle; cw\n    \n    void main() {\n      vec2 v = position - gl_FragCoord.xy / resolution;\n      float ang = atan(\n          1.0 - gl_FragCoord.y/resolution.y - position.y,\n          gl_FragCoord.x / resolution.x - position.x\n          );\n      ang += PI / 2.0;\n      if (ang < 0.0) { \n        ang = PI * 2.0 + ang;\n      }\n      ang = ang / (PI * 2.0); // in turn space (ie. 0..1)\n      ang = fract(-angle + ang);\n      if (isRepeat) {\n        ang = mod(ang, lastStopOffset);\n      }\n        \n      if (stopOffsets[0] >= ang) {\n        gl_FragColor = stopColors[0];\n      }\n      ${o.join("")}\n    }`}({maxStops:n});let i=null,f=null;const l=({width:o,height:s})=>{r=t({width:o,height:s,gl:r}),i=e.createProgramInfo(r,["attribute vec2 aPosition; void main() { gl_Position = vec4(aPosition, 0.0, 1.0); }\n",a]),f=e.createBufferInfoFromArrays(r,{aPosition:{numComponents:2,data:[-1,-1,-1,1,1,1,1,-1]}})};l({width:o,height:s});return{get gl(){return r},maxStops:n,render:t=>{const o=[r.canvas.width,r.canvas.height],s=[];for(const[o,e]of t.entries()){const{angle:t,position:r,stops:a,isRepeat:i}=e,f=i?a.length:1==a[a.length-1].offset?a.length:a.length+1;if(f>n)throw new Error(`gradients[${o}] has ${f} color stops (max=${n})`);const l=[],c=[];for(const{offset:t,color:o}of a)c.push(...o),l.push(t);const u=a[a.length-1].color;for(const t of Array(n+1-f).keys())l.push(1),c.push(...u);s.push({angle:t||0,position:r||[.5,.5],stopOffsets:l,stopColors:c,isRepeat:Boolean(i),desiredStopCount:f})}r.viewport(0,0,r.canvas.width,r.canvas.height),r.clear(r.COLOR_BUFFER_BIT),r.enable(r.BLEND),r.blendFunc(r.SRC_ALPHA,r.ONE_MINUS_SRC_ALPHA),r.useProgram(i.program),e.setBuffersAndAttributes(r,i,f);for(const{angle:t,position:n,stopColors:a,stopOffsets:l,isRepeat:c,desiredStopCount:u}of s)e.setUniforms(i,{resolution:o,angle:t,position:n,stopColors:a,stopOffsets:l,isRepeat:c,lastStopOffset:l[u-1]}),e.drawBufferInfo(r,f,r.TRIANGLE_FAN)},resize:l,toURL:({mimeType:t,quality:o}={})=>r.canvas.toBlob?function({canvas:t,mimeType:o,quality:s}){return new Promise((n,e)=>{t.toBlob(t=>{t?n(URL.createObjectURL(t)):e(new Error("no blob"))},o,s)})}({canvas:r.canvas,mimeType:t,quality:o}):function({canvas:t,mimeType:o,quality:s}){return Promise.resolve(t.toDataURL(o,s))}({canvas:r.canvas,mimeType:t,quality:o})}}}();ConGra.parser=function(){function t(t,o){switch(o){case"deg":return Number.parseFloat(t)/360;case"%":return Number.parseFloat(t)/100;case"turn":return Number.parseFloat(t);default:throw"failed to normalize unit"}}function o(o,s){try{return t(o,s)}catch(t){throw"failed to normalize stop offset"}}return{parse:function(s){const n={angle:0,position:[.5,.5],stops:[],isRepeat:!1};let e;{const t=s.match(/(repeating-)*conic-gradient\(([\s\S]+)\)/m);if(null===t)throw'failed to parse "conic-gradient()" pattern';if(!function(t){let o=0;for(const s of t)"("===s?o+=1:")"===s&&(o-=1);return 0===o}(t[2]))throw'failed to parse "conic-gradient()" pattern; braces not match';n.isRepeat=Boolean(t[1]),e=t[2]}{const s=e.match(/\s*(from\s+?(.+?)(turn|deg|%))*\s*(at\s+([^\s]+)%\s+([^\s]+)%)*\s*,*\s*([\s\S]*)$/m);if(null===s)throw"failed to parse definition";if(null===s[7])throw"color stop list is empty";s[1]&&s[2]&&s[3]&&(n.angle=function(o,s){try{return t(o,s)}catch(t){throw"failed to normalize angle"}}(s[2],s[3])),s[4]&&(void 0!==s[5]&&(n.position[0]=Number.parseFloat(s[5])/100),void 0!==s[6]&&(n.position[1]=Number.parseFloat(s[6])/100)),n.stops=function(t){const s=t.match(/rgba\(([\s\S]+?)\)(\s+[^,\s]+)*/g);if(null===s)throw"failed to parse color stop list";let n=[];for(const t of s){const s=t.match(/rgba\(\s*([^,]+)\s*,*\s*([^,]+)\s*,\s*([^,]+)\s*,\s*([^,]+)\s*\)\s*(([^\s]+)(deg|turn|%))*/m),e=[s[1]/255,s[2]/255,s[3]/255,s[4]],r=s[5]?o(s[6],s[7]):NaN;n.push({color:e,offset:r})}let e=[],r=0;for(const t of n)Number.isNaN(t.offset)?e.push(t):t.offset>=r?(e.push(t),r=t.offset):(t.offset=r,e.push(t));for(const[t,o]of e.entries())if(Number.isNaN(o.offset)){if(0===t){o.offset=0;continue}if(t===e.length-1){o.offset=1;continue}let s=t+1,n=e[s];for(;Number.isNaN(n.offset)&&s!==e.length-1;)n=e[s+=1];const r=e[t-1],a=e[e.length-1];o.offset=n===a?r.offset+(1-r.offset)/(s-t+1):r.offset+(n.offset-r.offset)/(s-t+1)}return e}(s[7])}return n}}}(),ConGra.polyfill=function(){return function({inputPrefix:t,maxImage:o,outputSuffix:s,root:n}){if(!n)throw'must provide "root" in option object';const e=function({root:t,inputPrefix:o,maxImage:s}){const n=[];t.style.setProperty(`${o}Allow`,"yes");const e=Array.from(t.querySelectorAll("*"));e.unshift(t);for(const t of e){const e=getComputedStyle(t);if("yes"!==e.getPropertyValue(`${o}Allow`).trim().toLowerCase())continue;const r={elm:t,cssStringDataList:[],cgDataList:[]};for(const t of Array(s).keys()){const s=t+1,n=`${o}${s}`,a=e.getPropertyValue(n).trim();a.length&&r.cssStringDataList.push({cssIndex:s,cssString:a,customPropName:n})}r.cssStringDataList.length>0&&n.push(r)}for(const t of n)for(const{cssString:o}of t.cssStringDataList){const s=ConGra.parser.parse(o);t.cgDataList.push(s)}return n}({root:n,inputPrefix:t,maxImage:o});console.log(e);for(const t of e){const o=t.elm,{width:n,height:e}=o.getBoundingClientRect();let r=0;for(const o of t.cgDataList){let t;(t=o.isRepeat?o.stops.length:1!=o.stops[o.stops.length-1].offset?o.stops.length+1:o.stops.length)>r&&(r=t)}const a=ConGra({width:n,height:e,maxStops:r,twgl:twgl});for(const[n,e]of t.cgDataList.entries())a.render([e]),a.toURL().then(e=>{const{customPropName:r}=t.cssStringDataList[n];o.style.setProperty(`${r}${s}`,`url(${e})`)})}}}(),ConGra.polyfill({inputPrefix:"--cg",maxImage:32,outputSuffix:"",root:document.body});