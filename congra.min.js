const ConGra=function(){function o({width:o,height:t,gl:n}){let e=n?n.canvas:document.createElement("canvas");return e.width=o,e.height=t,e.getContext("webgl",{premultipliedAlpha:!1})}return function({width:t,height:n,maxStops:e,twgl:s}){let a=o({width:t,height:n});const i=function({maxStops:o=4}){const t=[];for(const n of Array(o).keys())0!=n&&t.push(`\n    else if (stopOffsets[${n}] >= ang) {\n      float ratio = (ang - stopOffsets[${n-1}])/(stopOffsets[${n}] - stopOffsets[${n-1}]);\n      gl_FragColor = mix(stopColors[${n-1}], stopColors[${n}], ratio);\n    }`);return`precision lowp float;\n    const float PI = ${Math.PI};\n    uniform vec2 resolution;\n    uniform vec2 position;\n    uniform vec4 stopColors[${o}];\n    uniform float stopOffsets[${o}];\n    uniform bool isRepeat;\n    uniform float lastStopOffset;\n    uniform float angle; // offset of start angle; cw\n    \n    void main() {\n      vec2 v = position - gl_FragCoord.xy / resolution;\n      float ang = atan(\n          1.0 - gl_FragCoord.y/resolution.y - position.y,\n          gl_FragCoord.x / resolution.x - position.x\n          );\n      ang += PI / 2.0;\n      if (ang < 0.0) { \n        ang = PI * 2.0 + ang;\n      }\n      ang = ang / (PI * 2.0); // in turn space (ie. 0..1)\n      ang = fract(-angle + ang);\n      if (isRepeat) {\n        ang = mod(ang, lastStopOffset);\n      }\n        \n      if (stopOffsets[0] >= ang) {\n        gl_FragColor = stopColors[0];\n      }\n      ${t.join("")}\n    }`}({maxStops:e});let r=null,f=null;const l=({width:t,height:n})=>{a=o({width:t,height:n,gl:a}),r=s.createProgramInfo(a,["attribute vec2 aPosition; void main() { gl_Position = vec4(aPosition, 0.0, 1.0); }\n",i]),f=s.createBufferInfoFromArrays(a,{aPosition:{numComponents:2,data:[-1,-1,-1,1,1,1,1,-1]}})};l({width:t,height:n});return{get gl(){return a},maxStops:e,render:o=>{const t=[a.canvas.width,a.canvas.height],n=[];for(const[t,s]of o.entries()){const{angle:o,position:a,stops:i,isRepeat:r}=s,f=r?i.length:1==i[i.length-1].offset?i.length:i.length+1;if(f>e)throw new Error(`gradients[${t}] has ${f} color stops (max=${e})`);const l=[],p=[];for(const{offset:o,color:t}of i)p.push(...t),l.push(o);const g=i[i.length-1].color;for(const o of Array(e+1-f).keys())l.push(1),p.push(...g);n.push({angle:o||0,position:a||[.5,.5],stopOffsets:l,stopColors:p,isRepeat:Boolean(r),desiredStopCount:f})}a.viewport(0,0,a.canvas.width,a.canvas.height),a.clear(a.COLOR_BUFFER_BIT),a.enable(a.BLEND),a.blendFunc(a.SRC_ALPHA,a.ONE_MINUS_SRC_ALPHA),a.useProgram(r.program),s.setBuffersAndAttributes(a,r,f);for(const{angle:o,position:e,stopColors:i,stopOffsets:l,isRepeat:p,desiredStopCount:g}of n)s.setUniforms(r,{resolution:t,angle:o,position:e,stopColors:i,stopOffsets:l,isRepeat:p,lastStopOffset:l[g-1]}),s.drawBufferInfo(a,f,a.TRIANGLE_FAN)},resize:l,toURL:({mimeType:o,quality:t}={})=>a.canvas.toBlob?function({canvas:o,mimeType:t,quality:n}){return new Promise((e,s)=>{o.toBlob(o=>{o?e(URL.createObjectURL(o)):s(new Error("no blob"))},t,n)})}({canvas:a.canvas,mimeType:o,quality:t}):function({canvas:o,mimeType:t,quality:n}){return Promise.resolve(o.toDataURL(t,n))}({canvas:a.canvas,mimeType:o,quality:t})}}}();